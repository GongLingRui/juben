# 业务流程说明

## 业务流程概述

剧本创作 Agent 平台的核心业务流程包括用户交互、Agent执行、工作流编排、知识检索等多个环节。本章节详细描述各核心业务流程的执行逻辑。

## 目录

- [用户交互流程](#用户交互流程)
- [Agent执行流程](#agent执行流程)
- [工作流编排流程](#工作流编排流程)
- [知识检索流程](#知识检索流程)
- [项目管理流程](#项目管理流程)
- [特殊业务流程](#特殊业务流程)

## 用户交互流程

### 主聊天交互流程

**描述**: 用户与短剧策划助手进行完整交互的端到端流程

```mermaid
flowchart TD
    A[用户输入消息] --> B{意图识别}
    B -->|创作需求| C[启动策划Agent]
    B -->|评估需求| D[启动评估Agent]
    B -->|分析需求| E[启动分析Agent]
    B -->|未知意图| F[使用默认Agent]

    C --> G[加载会话上下文]
    D --> G
    E --> G
    F --> G

    G --> H{启用知识库?}
    H -->|是| I[检索相关知识]
    H -->|否| K[构建提示词]
    I --> J[补充上下文]
    J --> K

    K --> L[调用LLM]
    L --> M[流式返回响应]
    M --> N[保存消息记录]
    N --> O[更新会话状态]
    O --> P[返回结果给用户]
```

### 调用链路

**入口点**: `apis/core/api_routes.py::chat()`

**调用流程**:

```python
# 1. 请求参数解析与验证
chat_request = ChatRequest(**request_data)

# 2. 获取或创建Agent实例
agent = get_agent_instance(chat_request.agent_id)

# 3. 加载会话上下文
session = await storage_manager.get_session(chat_request.session_id)
history = await storage_manager.get_messages(session_id)

# 4. 知识库检索（可选）
if chat_request.enable_knowledge_base:
    knowledge = await knowledge_client.search(
        query=chat_request.input,
        collection=chat_request.collection,
        top_k=chat_request.top_k
    )

# 5. 构建输入并执行Agent
async for event in agent.process_request({
    "input": chat_request.input,
    "history": history,
    "knowledge": knowledge,
    "user_id": chat_request.user_id
}):
    yield event

# 6. 保存消息记录
await storage_manager.save_message(
    session_id=session.id,
    role="user",
    content=chat_request.input
)
await storage_manager.save_message(
    session_id=session.id,
    role="assistant",
    content=response_content
)
```

### 关键判断点

| 判断点 | 条件 | 处理路径 |
|--------|------|----------|
| 意图识别 | 用户输入包含"策划"、"创作"等关键词 | 路由到ShortDramaPlannerAgent |
| 意图识别 | 用户输入包含"评估"、"打分"等关键词 | 路由到ShortDramaEvaluationAgent |
| 意图识别 | 用户输入包含"分析"、"解读"等关键词 | 路由到分析类Agent |
| 知识库检索 | enable_knowledge_base=true | 执行向量检索并补充上下文 |
| 网络搜索 | enable_web_search=true | 执行网络搜索并补充上下文 |
| 会话存在 | session_id有效 | 加载历史消息 |
| 会话不存在 | session_id为空或无效 | 创建新会话 |

## Agent执行流程

### 标准Agent执行流程

**描述**: 单个Agent处理请求的标准流程

```mermaid
flowchart TD
    A[接收请求] --> B[解析输入参数]
    B --> C[加载系统提示词]
    C --> D[加载会话上下文]
    D --> E{需要知识增强?}
    E -->|是| F[执行知识检索]
    E -->|否| H[构建LLM输入]
    F --> G[补充检索结果]
    G --> H
    H --> I[调用LLM推理]
    I --> J[处理流式响应]
    J --> K[保存输出结果]
    K --> L[返回流式事件]
```

### 执行细节

**代码位置**: `agents/base_juben_agent.py::process_request()`

```python
async def process_request(self, request_data: Dict[str, Any]) -> AsyncGenerator[Dict[str, Any], None]:
    """处理请求的标准流程"""

    # 1. 初始化上下文
    self._current_user_id = request_data.get("user_id")
    self._current_session_id = request_data.get("session_id")

    # 2. 发送思考开始事件
    if self.enable_thought_streaming:
        yield {
            "type": "thought",
            "content": f"{self.agent_name}开始思考...",
            "step_number": 1
        }

    # 3. 构建输入
    messages = await self._build_messages(request_data)

    # 4. 调用LLM
    async for chunk in self._call_llm_stream(messages):
        if chunk.get("content"):
            yield {
                "type": "message",
                "content": chunk["content"],
                "content_type": "text"
            }

    # 5. 发送完成事件
    yield {
        "type": "done",
        "agent_name": self.agent_name,
        "timestamp": datetime.now().isoformat()
    }
```

### Agent分类执行策略

| Agent分类 | 执行策略 | 特殊处理 |
|-----------|----------|----------|
| 策划类 | 单次LLM调用 | 可能需要网络搜索补充 |
| 创作类 | 多轮迭代 | 支持内容扩展和修改 |
| 评估类 | 结构化输出 | 强制JSON格式输出 |
| 分析类 | 分阶段执行 | 先分析后总结 |
| 工作流类 | Agent编排 | 协调多个子Agent |
| 工具类 | 直接处理 | 不涉及LLM调用 |

## 工作流编排流程

### 情节点工作流

**描述**: 大情节点与详细情节点生成工作流

```mermaid
flowchart TD
    A[接收输入] --> B[输入验证]
    B --> C{验证通过?}
    C -->|否| D[返回错误]
    C -->|是| E[文本预处理]

    E --> F[文本截断]
    F --> G[文本分割]
    G --> H[生成文本片段]

    H --> I[并发调用Agent]
    I --> J1[故事大纲Agent]
    I --> J2[大情节点Agent]
    I --> J3[思维导图Agent]
    I --> J4[详细情节点Agent]

    J1 --> K[收集结果]
    J2 --> K
    J3 --> K
    J4 --> K

    K --> L{全部成功?}
    L -->|否| M[返回部分结果]
    L -->|是| N[调用输出格式化]

    N --> O[整合最终结果]
    O --> P[返回工作流完成]
```

### 并发控制机制

**代码位置**: `workflows/plot_points_workflow.py::_step_agent_coordination()`

```python
async def _step_agent_coordination(self):
    """智能体协调执行（带并发控制）"""

    # 使用信号量限制并发数量
    semaphore = asyncio.Semaphore(self.config.get("agent_concurrency_limit", 4))
    timeout = self.config.get("agent_call_timeout", 300)

    async def call_agent_with_timeout(agent_func, agent_name: str):
        """带超时控制的智能体调用"""
        async with semaphore:
            try:
                return await asyncio.wait_for(agent_func(), timeout=timeout)
            except asyncio.TimeoutError:
                return {"type": agent_name, "error": f"超时({timeout}秒)"}

    # 并行调用各个智能体
    agent_tasks = [
        call_agent_with_timeout(self._call_story_summary_agent, "story_summary"),
        call_agent_with_timeout(self._call_major_plot_points_agent, "major_plot_points"),
        call_agent_with_timeout(self._call_mind_map_agent, "mind_map"),
        call_agent_with_timeout(self._call_detailed_plot_points_agent, "detailed_plot_points")
    ]

    # 等待所有智能体完成
    results = await asyncio.gather(*agent_tasks, return_exceptions=True)
```

### 工作流配置

| 配置项 | 默认值 | 说明 |
|--------|--------|------|
| chunk_size | 10000 | 文本分割块大小 |
| length_size | 50000 | 文本截断长度 |
| parallel_limit | 10 | 并行处理限制 |
| agent_call_timeout | 300 | Agent调用超时（秒） |
| agent_concurrency_limit | 4 | 最大并发Agent数 |

### 关键判断点

| 判断点 | 条件 | 处理路径 |
|--------|------|----------|
| 输入验证 | 缺少input参数 | 返回参数错误 |
| 文本长度 | 超过length_size | 执行截断处理 |
| Agent超时 | 单个Agent执行超过300秒 | 记录错误，继续其他Agent |
| 结果收集 | 至少一个Agent成功 | 继续结果整合 |
| 结果收集 | 全部Agent失败 | 返回工作流失败 |

## 知识检索流程

### RAG知识检索流程

**描述**: 检索剧本创作知识库的完整流程

```mermaid
flowchart TD
    A[用户输入] --> B[提取查询关键词]
    B --> C[生成查询向量]
    C --> D[Milvus向量检索]
    D --> E[返回Top-K结果]
    E --> F[结果重排序]
    F --> G{置信度足够?}
    G -->|是| H[返回知识内容]
    G -->|否| I[返回无结果]
```

### 检索实现

**代码位置**: `utils/knowledge_base_client.py`

```python
async def search(self, query: str, collection: str, top_k: int = 5):
    """知识库搜索"""

    # 1. 生成查询向量
    embedding = await self._embed_text(query)

    # 2. 向量检索
    results = await self.milvus_client.search(
        collection_name=collection,
        data=[embedding],
        limit=top_k * 2  # 检索更多候选
    )

    # 3. 重排序
    reranked_results = await self._rerank(query, results[0])

    # 4. 返回Top-K
    return reranked_results[:top_k]
```

### BM25+向量混合检索

**代码位置**: `utils/bm25_retriever.py`

```python
async def hybrid_search(self, query: str, top_k: int = 5):
    """混合检索：BM25 + 向量检索"""

    # 1. BM25关键词检索
    bm25_results = self._bm25_search(query, top_k=top_k*2)

    # 2. 向量语义检索
    vector_results = await self._vector_search(query, top_k=top_k*2)

    # 3. 结果融合（RRF算法）
    final_results = self._reciprocal_rank_fusion(
        bm25_results,
        vector_results,
        k=60
    )

    return final_results[:top_k]
```

## 项目管理流程

### 项目创建流程

```mermaid
flowchart TD
    A[创建项目请求] --> B[验证名称]
    B --> C{名称有效?}
    C -->|否| D[返回错误]
    C -->|是| E[生成项目ID]
    E --> F[创建项目记录]
    F --> G[保存到数据库]
    G --> H[返回项目信息]
```

### 文件添加流程

**代码位置**: `apis/projects/api_routes_projects.py::create_project_file()`

```python
async def create_project_file(project_id: str, file_data: ProjectFileCreateRequest):
    """向项目添加文件"""

    # 1. 验证项目存在
    project = await project_manager.get_project(project_id)
    if not project:
        raise HTTPException(404, "项目不存在")

    # 2. 创建文件记录
    file_id = str(uuid.uuid4())
    project_file = ProjectFile(
        id=file_id,
        project_id=project_id,
        filename=file_data.filename,
        file_type=file_data.file_type,
        content=file_data.content,
        agent_source=file_data.agent_source,
        tags=file_data.tags,
        created_at=datetime.now(),
        file_size=len(str(file_data.content))
    )

    # 3. 保存文件
    await project_manager.save_file(project_file)

    # 4. 更新项目文件计数
    await project_manager.update_file_count(project_id)

    return project_file
```

## 特殊业务流程

### 智能意图识别流程

**描述**: 自动识别用户意图并路由到合适的Agent

```mermaid
flowchart TD
    A[用户输入] --> B[提取关键词]
    B --> C[意图分类]
    C --> D{策划类?}
    C --> E{创作类?}
    C --> F{评估类?}
    C --> G{分析类?}

    D -->|是| H[ShortDramaPlannerAgent]
    E -->|是| I[ShortDramaCreatorAgent]
    F -->|是| J[ShortDramaEvaluationAgent]
    G -->|是| K[分析类Agent]

    H --> L[执行Agent]
    I --> L
    J --> L
    K --> L
    L --> M[返回结果]
```

**代码位置**: `utils/intent_recognition.py`

```python
async def recognize_intent(self, user_input: str) -> str:
    """识别用户意图"""

    # 关键词匹配规则
    intent_rules = {
        "planning": ["策划", "规划", "方案", "大纲"],
        "creation": ["创作", "写", "生成", "编写"],
        "evaluation": ["评估", "评价", "打分", "质量"],
        "analysis": ["分析", "解读", "拆解", "研究"]
    }

    # 匹配意图
    for intent, keywords in intent_rules.items():
        if any(kw in user_input for kw in keywords):
            return intent

    # 默认意图
    return "planning"
```

### 思维导图生成流程

**代码位置**: `agents/mind_map_agent.py`

```mermaid
flowchart TD
    A[接收故事内容] --> B[提取结构元素]
    B --> C[识别人物/情节/场景]
    C --> D[构建层级关系]
    D --> E[生成Markmap格式]
    E --> F[渲染为SVG]
    F --> G[上传到图床]
    G --> H[返回图片链接]
```

### 网络搜索流程

**代码位置**: `apis/baidu/api_routes_baidu.py`

```mermaid
flowchart TD
    A[搜索请求] --> B[调用百度API]
    B --> C[获取搜索结果]
    C --> D[解析HTML内容]
    D --> E[提取摘要信息]
    E --> F[结果排序]
    F --> G[返回结果列表]
```

### 人物关系分析流程

**代码位置**: `agents/character_relationship_analyzer_agent.py`

```mermaid
flowchart TD
    A[接收故事内容] --> B[识别人物实体]
    B --> C[提取关系描述]
    C --> D[构建关系图谱]
    D --> E[计算关系强度]
    E --> F[生成可视化数据]
    F --> G[返回关系网络]
```

## 错误处理流程

### 统一错误处理

**代码位置**: `utils/error_handler.py`

```mermaid
flowchart TD
    A[捕获异常] --> B{异常类型?}
    B -->|ValidationError| C[返回400错误]
    B -->|NotFoundError| D[返回404错误]
    B -->|TimeoutError| E[返回408错误]
    B -->|Exception| F[返回500错误]

    C --> G[记录错误日志]
    D --> G
    E --> G
    F --> G

    G --> H[返回错误响应]
```

### 重试机制

**代码位置**: `utils/llm_client.py::async_retry()`

```python
@async_retry(max_retries=3, delay=1.0, backoff=2.0)
async def call_llm_with_retry(self, messages: List[Dict]):
    """带重试的LLM调用"""

    # 首次调用
    try:
        return await self.llm_client.ainvoke(messages)
    except Exception as e:
        # 指数退避重试
        # delay * backoff^(attempt-1)
        # 1s -> 2s -> 4s
        raise
```

## 性能优化流程

### 连接池管理

**代码位置**: `utils/connection_pool_manager.py`

```mermaid
flowchart TD
    A[请求连接] --> B{连接池可用?}
    B -->|是| C[获取连接]
    B -->|否| D[创建新连接]
    C --> E[执行请求]
    D --> E
    E --> F[归还连接]
    F --> G[连接复用]
```

### 多级缓存策略

```mermaid
flowchart TD
    A[数据请求] --> B{L1缓存命中?}
    B -->|是| C[返回缓存数据]
    B -->|否| D{L2缓存Redis命中?}
    D -->|是| E[更新L1缓存]
    D -->|否| F[查询数据库]
    E --> C
    F --> G[更新L2缓存]
    G --> E
```

## 相关文档

- [接口文档](./接口文档.md) - API接口说明
- [领域模型说明](./领域模型说明.md) - 数据模型说明
- [项目结构说明](./项目结构说明.md) - 代码组织结构
